//---------------------------------------------------------------------------
#pragma hdrstop
#include "Matrix_for_lab.h"
#include <math.h>
#include <mem.h>
//---------------------------------------------------------------------------
TMatrix_4X4::TMatrix_4X4()
{
 for (char i = 0; i < 4 ; i++)
    for (char j = 0; j < 4 ; j++)
        Table[i][j] = 0;
};
//---------------------------------------------------------------------------
TMatrix_4X4::TMatrix_4X4(double value)
{
 for (char i = 0; i < 4 ; i++)
    for (char j = 0; j < 4 ; j++) // проверяем, если i и j = ,то value иначе - 0
        Table[i][j] = (j == i) ? value : 0;
 Table[3][3] = 1;
};
//---------------------------------------------------------------------------
TMatrix_4X4::TMatrix_4X4(const TMatrix_4X4 &Matr)
{
 memcpy(&Table, &Matr.Table, 16 * sizeof(double));
};
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::Add(const TMatrix_4X4 &Matr)
{
 TMatrix_4X4 *Res;
 Res = new TMatrix_4X4(*this);
 for (char i = 0; i < 4 ; i++)
   for (char j = 0; j < 4 ; j++)
      Res->Table[i][j] += Matr.Table[i][j];
 return *Res;
};
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::Deduction(const TMatrix_4X4 &Matr)   // вычитание
{
 TMatrix_4X4 Res(*this);
 for (char i = 0; i < 4 ; i++)
   for (char j = 0; j < 4 ; j++)
      Res.Table[i][j] -= Matr.Table[i][j];
 return Res;
};
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::Mull(const TMatrix_4X4 &Matr)   // умножение
{
 TMatrix_4X4 Res(0);
 Res.Table[3][3] = 0;
 for (char j = 0; j < 4 ; j++)
   for (char i = 0; i < 4 ; i++)
     for (char k = 0; k < 4; k++)
         Res.Table[i][j] = Res.Table[i][j] + Table[i][k] * Matr.Table[k][j];
 return Res;
};
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::Mull(const double value)   // умножение на число
{
 TMatrix_4X4 Res(*this);
 for (char i = 0; i < 4 ; i++)
   for (char j = 0; j < 4 ; j++)
      Res.Table[i][j] *= value;
 return Res;
};
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::Del(const double value)   // деление на число
{
 TMatrix_4X4 Res(*this);
 for (char i = 0; i < 4 ; i++)
   for (char j = 0; j < 4 ; j++)
      Res.Table[i][j] /= value;
 return Res;
};
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::RotateX(double angle)   // поворот на угол относ-но оси ОХ
{
 TMatrix_4X4 Res(1);

 double aSin = sin(angle);
 double aCos = cos(angle);

 Res.Table[1][1] = aCos;
 Res.Table[2][2] = aCos;
 Res.Table[1][2] = -aSin;
 Res.Table[2][1] = aSin;
return Res;
}
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::RotateY(double angle)   // поворот на угол относ-но оси ОХ
{
 TMatrix_4X4 Res(1);

 double aSin = sin(angle);
 double aCos = cos(angle);

 Res.Table[0][0] = aCos;
 Res.Table[2][2] = aCos;
 Res.Table[2][0] = aSin;
 Res.Table[0][2] = -aSin;
return Res;
}
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::RotateZ(double angle)   // поворот на угол относ-но оси ОХ
{
 TMatrix_4X4 Res(1);

 double aSin = sin(angle);
 double aCos = cos(angle);

 Res.Table[0][0] = aCos;
 Res.Table[1][1] = aCos;
 Res.Table[0][1] = aSin;
 Res.Table[1][0] = -aSin;
return Res;
}
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::Scale(double X, double Y, double Z)   // растяжение, сжатие
// если коэфф > 1 - растяжение || если 1 > коэфф > 0 - сжатие
{
 TMatrix_4X4 Res(1);

 Res.Table[0][0] = X;
 Res.Table[1][1] = Y;
 Res.Table[2][2] = Z;
return Res;
}
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::MirrorXOY()   // зеркало относ-но ХОY
{
 TMatrix_4X4 Res(1);
 Res.Table[2][2] = -1;
return Res;
}
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::MirrorYOZ()   // зеркало относ-но YOZ
{
 TMatrix_4X4 Res(1);
 Res.Table[0][0] = -1;
return Res;
}
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::MirrorZOX()   // зеркало относ-но ХОY
{
 TMatrix_4X4 Res(1);
 Res.Table[1][1] = -1;
return Res;
}
//---------------------------------------------------------------------------
TMatrix_4X4 TMatrix_4X4::Return()      // обратная
{
 return *this;
};
//---------------------------------------------------------------------------
void TMatrix_4X4::Mull(TVector3D &Vector)      // умножение на вектор
{
  double X = Table[0][0] * Vector.X + Table[1][0] * Vector.Y + Table[2][0] * Vector.Z;
  double Y = Table[0][1] * Vector.X + Table[1][1] * Vector.Y + Table[2][1] * Vector.Z;
  double Z = Table[0][2] * Vector.X + Table[1][2] * Vector.Y + Table[2][2] * Vector.Z;

  Vector.X = X;
  Vector.Y = Y ;
  Vector.Z = Z  ;
}
//---------------------------------------------------------------------------
void TMatrix_4X4::Mull(Tfloatv P)                         // умножение на массив из 3 с плавающ
{
  double X = Table[0][0] * P[0] + Table[1][0] * P[1] + Table[2][0] * P[2];
  double Y = Table[0][1] * P[0] + Table[1][1] * P[1] + Table[2][1] * P[2];
  double Z = Table[0][2] * P[0] + Table[1][2] * P[1] + Table[2][2] * P[2];

  P[0] = X;
  P[1] = Y ;
  P[2] = Z  ;
}
//---------------------------------------------------------------------------


//===========================  ДЛЯ ВЕКТОРОВ 3D ===========================\\

//---------------------------------------------------------------------------
 TVector3D::TVector3D() //Создается 0 вектор
 {
  X = 0;
  Y = 0;
  Z = 0;
  P = 1;
 }
//---------------------------------------------------------------------------
 TVector3D::TVector3D(double Value) //Создается вектор c X,Y,Z = Value
 {
  X = Value;
  Y = Value;
  Z = Value;
  P = 1;
 }
//---------------------------------------------------------------------------
 TVector3D::TVector3D(double vX, double vY, double vZ, double vP) //Создается заданный вектор
 {
  X = vX;
  Y = vY;
  Z = vZ;
  P = vP;
 }
//---------------------------------------------------------------------------
 void TVector3D::Copy(const TVector3D &Vec) //вектор копируются с другого
 {
  X = Vec.X;
  Y = Vec.Y;
  Z = Vec.Z;
  P = Vec.P;
 };
//---------------------------------------------------------------------------
 TVector3D TVector3D::Add(const TVector3D &Vector)
 {
  TVector3D Res(0);
  Res.X = X + Vector.X;
  Res.Y = Y + Vector.Y;
  Res.Z = Z + Vector.Z;
  Res.P = P + Vector.P;
  return Res;
 };
//---------------------------------------------------------------------------
 TVector3D TVector3D::Minus()
 {
  return TVector3D(-X, -Y, -Z, -P);
 };
//---------------------------------------------------------------------------
 TVector3D TVector3D::Deduction(const TVector3D &Vector)
 {
 TVector3D Res;
  Res.X = X - Vector.X;
  Res.Y = Y - Vector.Y;
  Res.Z = Z - Vector.Z;
  Res.P = P - Vector.P;
  return Res;
 };
//---------------------------------------------------------------------------
 double TVector3D::MullSc(const TVector3D &Vector)
 {
  double Res = 0;
  Res = X * Vector.X + Y * Vector.Y + Z * Vector.Z + P * Vector.P;
  return Res;
 };
//---------------------------------------------------------------------------
 TVector3D TVector3D::Del(const TVector3D &Vector)
 {
 TVector3D Res;
  Res.X = X / Vector.X;
  Res.Y = Y / Vector.Y;
  Res.Z = Z / Vector.Z;
  Res.P = P / Vector.P;
  return Res;
 };
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
 TVector3D TVector3D::Del(double Value)
 {
 TVector3D Res;
  Res.X = X / Value;
  Res.Y = Y / Value;
  Res.Z = Z / Value;
  Res.P = P / Value;

  return Res;
 };
//---------------------------------------------------------------------------
 double  TVector3D::Length()
 {
  double Len;
  try
  {
   Len = sqrt(X * X + Y * Y + Z * Z);
  }
  catch(...)
  {
   Len = 0;
  }
  return Len;
 };
//---------------------------------------------------------------------------
void TVector3D::OneV()                              //привидение к еденичному
 {
  P = Length();
  if (P != 0)
    {
     X /= P;
     Y /= P;
     Z /= P;
     P = Length();
    }
 }
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma package(smart_init)


/*    Перегрузка операторов
 TVector3D & operator *= (const TVector3D &Vec)
 {
  X *= Vec.X;
  Y *= Vec.Y;
  Z *= Vec.Z;
  P *= Vec.P;
  return *this;
 };

 TVector3D & operator /= (const TVector3D &Vec)
 {
  X /= Vec.X;
  Y /= Vec.Y;
  Z /= Vec.Z;
  P /= Vec.P;
  return *this;
 };

 TVector3D & operator *= (double F)
 {
  X *= F;
  Y *= F;
  Z *= F;
  P *= F;
  return *this;
 };

 TVector3D & operator /= (double F)
 {
  X /= F;
  Y /= F;
  Z /= F;
  P /= F;
  return *this;
 }; */
